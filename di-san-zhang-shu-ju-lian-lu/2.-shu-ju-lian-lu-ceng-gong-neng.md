# 2. 数据链路层功能

数据链路层在物理层提供服务的基础上**向网络层提供服务**，其最基本的服务是将源自网络层来的数据**可靠**地传输到相邻节点的目标机网络层。

其主要作用是**加强物理层传输原始比特流的功能**，将物理层提供的可能出错的物理连接改造为**逻辑上无差错的数据链路**，使之对网络层表现为一条无差错的链路。

* **功能一：**为网络层提供服务。**无确认无连接服务**、**有确认无连接服务**、**有确认面向连接服务（有连接一定有确认）**。
* **功能二：**链路管理，即连接的建立、维持、释放（用于面向连接的服务）。
* **功能三：**组帧
* **功能四：**流量控制
* **功能五：**差错控制（帧错 / 位错）

## 1. 封装成帧 & 透明传输

### 1.1 封装成帧

**封装成帧（framing）**就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别出帧的开始和结束。

首部和尾部包含许多的控制信息，它们的一个重要作用：**帧定界**（确定帧的界限）。

**帧同步：接收方**应当能从接受到的二进制比特流中区分出帧的起始和终止。

**最大传送单元 MTU**（Maximum Transfer Unit）：规定帧的**数据部分的长度上限**

**组帧的四种方法：**1. 字符计数法，2. 字符（节）填充法，3. 零比特填充法，4. 违规编码法

![](../.gitbook/assets/image%20%2863%29.png)

### **1.2 透明传输**

**透明传输：**指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路就 “看不见” 有什么妨碍数据传输的东西。

当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。

### 1.3 组帧方法

#### 1. 字符计数法（不常用）

帧首部使用一个计数字段（第一个**字节**，八位）来标明帧内字符数。

![](../.gitbook/assets/image%20%2844%29.png)

**缺点：**如果第一个字节出现了错误，就会导致整个帧判断错误

#### 2. 字符填充法

帧的首部用 SOH（Start Of Header）表示，尾部用 EOT（End Of Transmission）表示。如图所示：

![](../.gitbook/assets/image%20%2829%29.png)

**使用情况：**

1. ![](../.gitbook/assets/image%20%2848%29.png) 当传送的帧是由文本文件组成时（文本文件的字符都是从键盘上输入的，都是 ASCII 码）。不管从键盘上输入什么字符都可以放在帧里传过去，即**透明传输**。
2. ![](../.gitbook/assets/image%20%2871%29.png) 当传送的帧是由非 ASCII 码的文本组成时（二进制代码的程序或图像等）。就要**采用字符填充方法实现透明传输**。
   * 当帧中出现控制字符 “SOH” 或 “EOT” 的前面插入一个**转义字符 “ESC”**（其十六进制编码是 1B，二进制是 0001 1011）
   * 在**接收端**的数据链路层在把数据送往网络层之前删除这个插入的转义字符
   * 如果转义字符也出现在数据部分中，解决方法是在转义字符前面插入一个转义字符

![](../.gitbook/assets/image%20%2828%29.png)

#### 3. 零比特填充法

在首部和尾部均用 0x7E（二进制：0111 1110）表示

![](../.gitbook/assets/image%20%2834%29.png)

**操作：**

1. 在发送端，扫描整个信息字段，只要连续 5 个 1，就立即填入 1 个 0

   ![](../.gitbook/assets/image%20%2868%29.png) 

2. 在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续 5 个 1 时，就把后面的 0 删除。

   ![](../.gitbook/assets/image%20%2860%29.png) 

**保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。**

#### 4. 违规编码法

曼彻斯特编码： ![](../.gitbook/assets/image%20%2865%29.png) 

由于曼彻斯特编码只会出现 **高-低**、**低-高** 的情况，所以我们可以使用 **高-高**，**底-底** 来定界帧的起始和终止。

**总结：**由于字节计数法中 Count 字段的脆弱性（其值若有差错将导致灾难性后果）及字符填充法实现上的复杂性和不兼容新，目前较普遍使用的帧同步是**比特填充**（零比特填充）和**违规编码法**。

## 2. 差错控制（检错编码）

### 2.1 差错从何而来？

概括的来说，传输中的差错都是由于**噪声引起**的。

* **（全局性）**由于线路本身电气特性所产生的的**随机噪声**（热噪声），是信道固有的，随机存在的。
  * **解决办法：**提高信噪比来减少或避免干扰。（对传感器下手）
* **（局部性）**外界特定的短暂原因所造成的**冲击噪声**，是产生差错的主要原因。
  * **解决办法：**通常利用编码技术来解决

差错的分类：

* **位错：**比特位出错，1 变为 0，0 变为 1
* **帧错：**
  * **帧丢失：**收到 \[\#1\]-\[\#3\]（丢失 \[\#2\]）
  * **帧重复：**收到 \[\#1\]-\[\#2\]-\[\#2\]-\[\#3\]（收到两个 \[\#2\]）
  * **帧失序：**收到 \[\#1\]-\[\#3\]-\[\#2\]

数据链路层为网络层提供服务：

* **无确认**无连接服务
  * 通信质量**好**的**有线**传输链路
  * 数据链路层**不**使用**确认**和**重传机制**，由上层传输层来解决
* **有确认**无连接服务、**有确认**面向连接服务
  * 通信质量**差**的**无线**传输链路
  * 数据链路层**使用确认**和**重传机制**

### 2.2 检错方法

差错控制（比特错）

* 检错编码
  * 奇偶校验码
  * 循环冗余码 CRC
* 纠错编码
  * 海明码

**冗余编码**

在数据发送前，先按照某种关系**附加**上一定的**冗余位**，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使码字遵从不变的规则。接收端根据收到码字是否仍然符合原规则，从而判断是否出错。

**概念辨析：编码 VS 编码**

数据链路层编码和物理层的数据编码与调制**不同**。物理层编码针对的是**单个比特**，解决传输过程中比特的同步问题，如曼彻斯特编码。而数据链路层的编码针对的是**一组比特**，它通过冗余码的技术实现一组二进制比特串在传输过程是否出现了差错。

#### 奇偶校验码

![](../.gitbook/assets/image%20%2861%29.png)

奇偶校验码特点：只能检查出**奇数个比特错误**，检错能力为 50%

#### CRC循环冗余码

1. 准备待传有效数据

   ![](../.gitbook/assets/image%20%2864%29.png) 

2. 每组都加上冗余码构成帧再发送

   ![](../.gitbook/assets/image%20%2850%29.png) 

   FCS 帧检验序列计算方式：

   ![](../.gitbook/assets/image%20%2847%29.png) 

3. 接收方检验

   ![](../.gitbook/assets/image%20%2856%29.png) 

例子：

![](../.gitbook/assets/image%20%2832%29.png)

**接收端检错过程：**把收到的每一个帧都除以同样的除数 P，然后检查得到的余数 R

* 若得到的余数 $$R = 0 $$ ，则判定这个帧没有差错，接受
* 若得到的余数 $$R \neq 0$$ ，则判定这个帧有差错，丢弃

FCS 的生成以及接收端 CRC 检验都是由**硬件**实现，处理很迅速，因此不会延误数据的传输。

在数据链路层若**仅仅**使用循环冗余检验 CRC 差错检测技术，只能做到对帧的**无差错接受**，即：**“凡是接收端数据链路层接受帧，我们就能非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”**。

**可靠传输：**数据链路层发送端发送什么，接收端就收到什么。

数据链路层使用 CRC 检验，能够实现无比特差错传输，但这还不是可靠传输。

## 3. 差错控制（纠错编码）

### 3.1 基本概念

对于奇偶校验码，只能**发现错误**

而对于纠错编码——**海明码**，可以**发现错误**、**找到位置**、**纠正错误**

**海明码距**

两个合法编码（码字）的对应比特取值不同的比特数称为这两个码字的**海明距离（码距）**；

![](../.gitbook/assets/image%20%2845%29.png) 只有一位不同，所以码距为 1

一个有效编码集中，任意两个合法编码（码字）的海明码距离的最小值称为该编码集的**海明距离（码距）**。

![](../.gitbook/assets/image%20%2855%29.png)

当码距为 n 时，可以检查出 n - 1 位的错误

**结论：**当需要检查出 d 为错误，需要码距为 d + 1；当需要纠正 d 为错误，需要码距为 2d + 1

### **3.2 工作流程**

![](../.gitbook/assets/image%20%2839%29.png)

1. 确定校验码位数 r

   ![](../.gitbook/assets/image%20%2862%29.png) 

   ![](../.gitbook/assets/image%20%2846%29.png) 

2. 确定校验码和数据的位置

   ![](../.gitbook/assets/image%20%2836%29.png) 

3. 求出校验码的值

   ![](../.gitbook/assets/image%20%2841%29.png) 

4. 检查并纠错

   ![](../.gitbook/assets/image%20%2840%29.png) 

   ![](../.gitbook/assets/image%20%2872%29.png) 

   ![](../.gitbook/assets/image%20%2853%29.png) 

## 4. 差错控制知识脑图

![](../.gitbook/assets/cha-cuo-kong-zhi-.svg)

## 5. 流量控制 & 可靠传输机制



