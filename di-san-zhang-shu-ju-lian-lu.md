# 第...章：数据链路层

数据链路层主要处理局域网内的寻址（通过 MAC 地址）

数据链路层主要使用的**信道**有以下两种类型：

* 点对点信道
* 广播信道

## 1. 使用点对点信道的数据链路层

### 1.1 数据链路和帧

**链路（link）：**从一个结点到**相邻结点**的一段物理路线，而中间没有任何其他交换结点。

**数据链路（data link）：**数据在一条路线上传输时，除了必须有的一条物理路线外，还必须有一些通信协议来控制这些数据的传输。若**把实现这些协议的硬件和软件加到链路连上**，就构成了数据链路。

**帧：**数据链路层把网络层交下来的数据，添加自己的首部和尾部，构成帧，传输出去。

![](.gitbook/assets/image%20%2839%29.png)

点对点信道的数据链路层在进行通信时的主要步骤为：

1. 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧
2. 结点 A 把封装好的帧发送给结点 B 的数据链路层
3. 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧

### 1.2 三个基本问题

数据链路层的协议有很多，但是三个基本问题是共同的。这三个基本问题是：**封装成帧、透明传输、差错检测**。

#### 1.2.1 封装成帧

**封装成帧（framing）**就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。

首部和尾部的作用：**帧定界**（确定帧的界限）。接收端在收到物理层上交的比特流后，就可以根据首部和尾部的标记，识别出帧的开始和结束。

**最大传送单元 MTU**（Maximum Transfer Unit）：规定帧的**数据部分的长度上限**

![&#x7528;&#x5E27;&#x9996;&#x90E8;&#x548C;&#x5E27;&#x5C3E;&#x90E8;&#x5C01;&#x88C5;&#x6210;&#x5E27;](.gitbook/assets/image%20%2840%29.png)

**帧定界**

* 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的**帧定界符**
* 如果接收端收到的帧没有发现帧结束符，说明该帧是不完整的，丢弃

如下图所示：首部用 SOH（Start Of Header）表示；尾部用 EOT（End Of Tail）表示

注意：SOH 和 EOT 并不是用六个字母表示的，仅仅是控制字符的名称，它们十六进制的编码分别是 01（二进制是 0000 0001）和 04（二进制是 0000 0100）。因为这两个控制字符是 ASCII 码中不可打印的，所以选用它们，这样可以避免和帧的数据部分发生冲突。

![&#x7528;&#x63A7;&#x5236;&#x5B57;&#x7B26;&#x8FDB;&#x884C;&#x5E27;&#x5B9A;&#x754C;&#x7684;&#x65B9;&#x6CD5;&#x4E3E;&#x4F8B;](.gitbook/assets/image%20%2832%29.png)

#### 1.2.2 透明传输

**透明：**某一个实际存在的事物看起来却好像不存在一样。

**在数据链路层的透明传送数据：**表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。

对于封装成帧中的帧定界符的选取方法，仅仅针对帧的数据部分是可打印的 ASCII 码，但是并非所有的数据都是这样的。所以对一一个非 ASCII 码的数据时，会出现一种情况，数据部分刚好包含 SOH 或 EOT 这种控制字符。数据链路层会**错误地** “找到帧的边界”，把部分帧收下（误认为是完整的帧），而把剩下的那部分数据丢弃。如果所示：

![&#x6570;&#x636E;&#x90E8;&#x5206;&#x6070;&#x597D;&#x51FA;&#x73B0;&#x4E8E;EOT&#x4E00;&#x6837;&#x7684;&#x4EE3;&#x7801;](.gitbook/assets/image%20%2835%29.png)

解决上述问题的方法：**字节填充**（byte stuffing）或**字符填充**（character stuffing）

* **发送端**的数据链路层在数据中出现控制字符 “SOH” 或 “EOT” 的前面插入一个**转义字符 “ESC”**（其十六进制编码是 1B，二进制是 0001 1011）
* 在**接收端**的数据链路层在把数据送往网络层之前删除这个插入的转义字符
* 如果转义字符也出现在数据部分中，解决方法是在转义字符前面插入一个转义字符

![&#x7528;&#x5B57;&#x8282;&#x586B;&#x5145;&#x6CD5;&#x89E3;&#x51B3;&#x900F;&#x660E;&#x4F20;&#x8F93;&#x7684;&#x95EE;&#x9898;](.gitbook/assets/image%20%2834%29.png)

#### 1.2.3 差错检测

**比特差错：**现实的通信链路都不会是理想的，比特在传输的过程中可能产生差错，1 可能会变为 0，而 0 也可能变为 1。

数据链路层广泛使用 **循环冗余检验 CRC**的检查技术。

CRC 的原理：

* 假设一个分组的数据 M 为 k 个比特，除数为 P
* 对数据做模运算（M % P）
* 把模运算的结果加到 M 的后面

**帧检验序列 FCS：**为了进行检错而添加的冗余码（模运算的结果）

示例：M = 101001（k = 6），P = 1101

![](.gitbook/assets/image%20%2831%29.png) 

> 运算后，余数为 001，把这个数拼接到 M 后面，即 101001 001

接收端把接收到的数据以帧为单位进行 CRC 检验：把收到的每一个帧都除以同样的除数 P，然后检查得到的余数 R

* 若得到的余数 $$R = 0 $$ ，则判定这个帧没有差错，接受
* 若得到的余数 $$R \neq 0$$ ，则判定这个帧有差错，丢弃

**重要理解：**

* 在数据链路层若**仅仅**使用循环冗余检验 CRC 差错检测技术，只能做到对帧的**无差错接受**，即：**“凡是接收端数据链路层接受帧，我们就能非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”**。
* 注意，数据链路层**仅仅**对帧进行**差错检测**，并不能提供**可靠传输**的服务。更具体的，差错检测，只能检测出比特差错，即：帧的数据部分的比特由1变为0，由0变为1。
* 还有一类更复杂的传输差错，数据链路层检测不出来，即：收到的帧没有出现比特差错，但是出现了**帧丢失、帧重复**或**帧失序**。如：发送三个帧：\[\#1\]-\[\#2\]-\[\#3\]
  * **帧丢失：**收到 \[\#1\]-\[\#3\]（丢失 \[\#2\]）
  * **帧重复：**收到 \[\#1\]-\[\#2\]-\[\#2\]-\[\#3\]（收到两个 \[\#2\]）
  * **帧失序：**收到 \[\#1\]-\[\#3\]-\[\#2\]

